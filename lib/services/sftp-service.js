// Generated by CoffeeScript 1.7.1
(function() {
  var async, aws, client, dump, errorQ, file_check, fs, get_all_files, get_dump_hierarchy, get_valid_list, heroku, ingestorQ, move_to_temp, path, rabbit_mq, shiftBucket, split_array, valid_file, _;

  client = require('ssh2-sftp-client');

  aws = require('./aws_s3');

  async = require('async');

  path = require('path');

  rabbit_mq = require('./rabbitMQ/send');

  _ = require('underscore');

  heroku = require('../../etc/heroku');

  fs = require('fs');

  ingestorQ = heroku.config.rabbitMq.ingestorQ;

  errorQ = heroku.config.rabbitMq.errorQ;

  shiftBucket = heroku.config.aws.shiftBucket;

  dump = {
    dirname: 'backup'
  };

  exports.send_sftp_file = function(contents, site, done) {
    var sc;
    console.log('hitting sftp service method');
    sc = new client();
    return sc.connect({
      host: site.host,
      port: site.port,
      username: site.username,
      password: site.password
    }).then(function(d) {
      var buf, p;
      buf = Buffer.from(contents.toString(), 'utf8');
      p = path.join('./', site.destination_dir.toString(), '/BT9000 Price Book.xml');
      return sc.put(buf, p);
    }).then(function(result) {
      return done(null, 'file send ok');
    })["catch"](function(err) {
      console.log(err);
      return done(err, null);
    });
  };

  exports.test_connection = function(body, done) {
    var s;
    console.log('hitting test connection method');
    console.log(body);
    s = new client();
    return s.connect({
      host: body.host,
      port: body.port,
      username: body.username,
      password: body.password,
      PreferredAuthentications: "password",
      PubkeyAuthentication: "no",
      debug: console.log
    }).then(function(d) {
      console.log('then');
      return s.list(body.source);
    }).then(function(list) {
      if (list.length < 700) {
        return get_valid_list(list, body.validations.toString(), function(err, new_list) {
          s.end();
          if (err != null) {
            return done(null, list);
          } else {
            return done(null, new_list);
          }
        });
      } else {
        s.end();
        return done(null, list);
      }
    })["catch"](function(err) {
      console.log('in catch block');
      s.end();
      return done(err, null);
    });
  };

  get_dump_hierarchy = function(millisec) {
    var t;
    t = new Date(1970, 0, 1);
    t.setTime(millisec);
    return path.join(t.getFullYear().toString(), (t.getMonth() + 1).toString(), t.getDate().toString());
  };

  move_to_temp = function(sftp, site, file, done) {
    var basic_url, valid;
    basic_url = site.sftp.source;
    valid = site.sftp.validation;
    console.log(valid);
    console.log(file);
    return file_check(file.name, valid, function(err, fileType) {
      var f_path, n_path, xsite_path;
      if (err != null) {
        console.log(err);
        return done(err, null);
      } else {
        console.log('this is file type from moving method : ' + fileType);
        f_path = path.join(basic_url, file.name);
        n_path = path.join(basic_url, dump.dirname, fileType, get_dump_hierarchy(file.modifyTime).toString(), file.name);
        xsite_path = path.join(basic_url, dump.dirname, fileType, get_dump_hierarchy(file.modifyTime).toString(), (Date.now() + 'xsite' + file.name).toString());
        return sftp.mkdir(path.join(basic_url, dump.dirname, fileType, get_dump_hierarchy(file.modifyTime)), true).then(function() {
          return sftp.rename(f_path, n_path).then(function() {
            return done(null, 'ok');
          })["catch"](function(err) {
            console.log('renaming file and back up again');
            return sftp.rename(f_path, xsite_path).then(function() {
              return done(null, 'ok');
            })["catch"](function(error) {
              return done(error, null);
            });
          });
        })["catch"](function(e) {
          return done(e, null);
        });
      }
    });
  };

  valid_file = function(file_name, expressions) {
    return file_name.match(/^[0-9]+\.xml/g);
  };

  get_all_files = function(sftp, site, list, done) {
    var get_file_data;
    get_file_data = function(file, cb) {
      var file_path;
      file_path = path.join(site.sftp.source, file.name);
      console.log('getting file: ' + file_path);
      return sftp.get(file_path).then(function(data) {
        var fl_data;
        fl_data = '';
        data.on('data', function(chunk) {
          console.log('getting data chunk: %d for file: %s site: %d', chunk.length, file.name, site.id);
          return fl_data = fl_data + chunk;
        });
        return data.on('end', function() {
          var file_name, options;
          console.log('uploading: ' + file.name);
          file_name = path.join(site.client_id.toString(), site.id.toString(), 'pending', file.type.toString(), file.name.toString());
          options = {
            bucket: shiftBucket,
            key: file_name,
            body: fl_data.toString()
          };
          return aws.awsTransferUpload(options, function(err, results) {
            var Q_msg;
            if (err != null) {
              console.log(options);
              console.log(err);
              Q_msg = {
                client_id: site.client_id.toString(),
                site_id: site.id.toString(),
                service: 'errors',
                status: 'awsUpload',
                file: file.name.toString(),
                bucket: shiftBucket,
                body: 'AWS:Error in uploading file: ' + err
              };
              return rabbit_mq.send_msg(errorQ, JSON.stringify(Q_msg), function(err, r) {
                if (err != null) {
                  return cb(err, null);
                } else {
                  return cb(null, 'ok');
                }
              });
            } else {
              console.log('-------- Upload complete for: ' + file_name);
              return move_to_temp(sftp, site, file, function(err, r) {
                if (err != null) {
                  Q_msg = {
                    client_id: site.client_id.toString(),
                    site_id: site.id.toString(),
                    service: 'errors',
                    status: 'moveBackup',
                    file: file_name,
                    bucket: shiftBucket,
                    body: 'Error in file moving to backup folder' + err
                  };
                } else {
                  Q_msg = {
                    client_id: site.client_id.toString(),
                    site_id: site.id.toString(),
                    pos: site.pos,
                    dump_her: get_dump_hierarchy(file.modifyTime).toString(),
                    service: 'ingestor',
                    status: 'ok',
                    file: file_name,
                    bucket: shiftBucket,
                    body: 'new file to parse'
                  };
                }
                console.log('queue: ' + ingestorQ);
                return rabbit_mq.send_msg(ingestorQ, JSON.stringify(Q_msg), function(err, r) {
                  if (err != null) {
                    console.log(err);
                    return cb(err, null);
                  } else {
                    return cb(null, 'ok');
                  }
                });
              });
            }
          });
        });
      })["catch"](function(error) {
        return cb(error, null);
      });
    };
    return async.eachLimit(list, heroku.config.parallel.uploadFiles, get_file_data, function(err) {
      if (err != null) {
        return done(err, null);
      } else {
        return done(null, 'ok');
      }
    });
  };

  file_check = function(name, matcher, cb) {
    var error, exp, get_match, m, matchers, re, _i, _len;
    try {
      get_match = null;
      matchers = matcher.split(",");
      for (_i = 0, _len = matchers.length; _i < _len; _i++) {
        re = matchers[_i];
        m = re.split("@");
        exp = new RegExp(m[1]);
        if (name.match(exp)) {
          get_match = m[0];
        }
      }
      if (get_match != null) {
        return cb(null, get_match);
      } else {
        return cb(null, null);
      }
    } catch (_error) {
      error = _error;
      return cb(error, null);
    }
  };

  split_array = function(array, n) {
    if (array.length) {
      return [array.splice(0, n)].concat(split_array(array, n));
    } else {
      return [];
    }
  };

  get_valid_list = function(list, validations, done) {
    var check_file_name, new_list, run, splitList;
    splitList = split_array(list, 500);
    new_list = [];
    check_file_name = function(l, cb) {
      if ((heroku.config.parallel.uploadAtTimes != null) && new_list.length > heroku.config.parallel.uploadAtTimes) {
        return async.setImmediate(function() {
          return cb(null, 'ok');
        });
      } else {
        return file_check(l.name, validations, function(err, type) {
          if ((type != null) && type !== 'undefined' && type !== null) {
            l.type = type;
            new_list.push(l);
            return async.setImmediate(function() {
              return cb(null, 'ok');
            });
          } else {
            return async.setImmediate(function() {
              return cb(null, 'ok');
            });
          }
        });
      }
    };
    run = function(li, cb2) {
      var err;
      li = _.filter(li, function(l) {
        return l.type === '-';
      });
      try {
        return async.eachSeries(li, check_file_name, function(err) {
          if (err != null) {
            console.log(err);
            return cb2(err, null);
          } else {
            return cb2(null, 'ok');
          }
        });
      } catch (_error) {
        err = _error;
        console.log(err);
        return cb2(err, null);
      }
    };
    return async.eachSeries(splitList, run, function(err) {
      if (err != null) {
        console.log(err);
        return done(err, null);
      } else {
        return done(null, new_list);
      }
    });
  };

  exports.get_sftp_files = function(site, done) {
    var sftp;
    sftp = new client();
    console.log('connecting host: ' + site.sftp.host);
    return sftp.connect({
      host: site.sftp.host,
      port: site.sftp.port,
      username: site.sftp.username,
      password: site.sftp.password
    }).then(function(d) {
      console.log('connected and getting list of files');
      return sftp.list(site.sftp.source);
    }).then(function(data) {
      return get_valid_list(data, site.sftp.validation, function(err, new_list) {
        console.log('Total Valid files for ' + site.name + ': ' + new_list.length);
        if ((new_list != null ? new_list.length : void 0) > 0) {
          return get_all_files(sftp, site, new_list, function(err, result) {
            if (err != null) {
              return done(err, null);
            } else {
              console.log('successfuly upload all the files for: ' + site.name + ' sites id: ' + site.id);
              return done(null, result);
            }
          });
        } else {
          console.log('No files for: ' + site.name + ' sites id: ' + site.id);
          return done(null, 'ok');
        }
      });
    })["catch"](function(err) {
      console.log(err);
      return done(err, null);
    });
  };

}).call(this);
